<html>
<head><title>HTTPi User's Manual</title></head>
<body bgcolor = "#ffffff" vlink = "#0000ff" link = "#0000ff" text = "#000000">
<a href ="./"><img src = "pix/httpismall.gif" alt = "[&lt;&lt;]" height = 32
width = 91 border = 0></a><i>Back to the main page</i>
<hr>
<img src = "pix/httpibig.gif" align = right alt = " ">
<h1>User's Manual</h1>
It would be greatly amiss if HTTPi didn't work at all like any other
webserver. Most of the time, you'll find that HTTPi behaves and operates
Pretty Much Like You'd Expect (tm). In fact, once running, it is actually
simpler (in the programmer's very biased opinion) to operate and maintain,
enable executables, and make documents available to be served; but, like
every piece of software, it does have its own idiosyncrasies.
If you think every webserver acts like Apache, you'd better read this
thoroughly first.
<a name = "ssto"><h3>Starting and Stopping HTTPi</h3></a>
Invoking and managing HTTPi sessions is very simple to do, and depending
on the way you have HTTPi installed, literally automatic.
<p>
If you have installed HTTPi to run in <code>(x)inetd</code>,
<code>stunnel</code> or <code>launchd</code>,
the superserver will manage HTTPi for you once it is configured.
<i>You'll never need to start your
server manually or place it in your system's <code>rc</code> scripts,
and will automatically manage all your server instances and/or virtual servers
for you if you have them set up.</i> You will not see any HTTPi processes
running when there are no requests pending. To stop the server, you must
manually remove the entry from your superserver's configuration.
<p>
Demonic HTTPi has some special care and feeding rules that are slightly
different than other webservers. In particular, you need one Demonic HTTPi
executable running per IP address it is bound to (so multiple virtual
servers require multiple instances of Demonic HTTPi built for each IP address
to separate executables).
These processes do not autostart, and should be
invoked in your system's <code>rc</code> scripts or equivalent such as
<code>launchd</code> itself to make sure
that your server comes up on reboot.
<p>
Demonic HTTPi
is invoked by simply calling it from the command line. You must be
<code>root</code> to bind TCP port numbers lower than 1024.
<p>
Prior to HTTPi 1.5, Demonic HTTPi tried to run within a single process and
open up additional forks only when requests arrive. This worked up until
Perl 5.8, which made significant internal changes (especially, but not
merely, with signals) rendering HTTPi incompatible.
<p>
To counter these architectural differences, in Demonic HTTPi 1.5 and up, two
processes are seen at any one time. The first is the parent process and is
generally idle, only serving to spawn a single child which is the one
actually listening on the port and doing the work. If you look at the
system's process list, you will see two entries for "<code>dhttpi</code>"
(which is what Demonic HTTPi calls itself): the first, the parent,
will display the current bound IP address, bound TCP port and the time of
last request,
allowing you to monitor the server remotely without sending fake requests to
check response.
The second, the child, will indicate which PID is monitoring it and its
status. Fortunately, you don't need to worry about the child process;
to stop the server, or a particular configured master instance,
simply <code>kill(1)</code>
the parent with a <code>TERM</code> signal and the parent will take down
the child for you. You will see additional processes for requests which
will automatically die when they are no longer needed.
<p>
You can also kill child processes off if they misbehave, which will
appropriately be respawned if needed. The owner of these processes may be
affected by the HTTPi Security Model (see below).
<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#e0e0ff">
As of 0.99, Demonic HTTPi optionally includes STATIOS, a configure-time
option allowing you to monitor your server's activity. STATIOS was
considerably expanded in 1.6. You can see
<a href = "/status">an example of the information it provides</a>
on this server. Log in as <code>voyeur</code>, password <code>wannapeek</code>.
</td></tr></table>
<a name = "desrv"><h3>Document Serving</h3></a>
HTTPi follows a simple rule. If the requested file is readable and exists, it
loads it and displays it. If the requested file is executable by the current
uid, it runs it instead. Everything else gets a 404 error.
Therefore, all you need to do to serve documents is make sure that HTTPi can
read it. If HTTPi is running as <code>root</code>, no worries; if it is
running as a non-privileged user, make sure you
<pre>
% chmod ugo+r {filename}
</pre>
so that it can see it, and
<pre>
% chmod ugo+rx {directory}
</pre>
on directories. Naturally, all documents must be in the documents directory
HTTPi is looking in, to ensure that naughtyness like
<a href = "/../../../etc/passwd"><code>/../../../etc/passwd</code></a>
doesn't work. Good thing, too.
<p>
Unlike just about every other webserver, if you don't have an
<code>index.html</code> file in a directory, you'll get an error, not a
directory tree. This is to save program code and server size, and also
offers a modicum of security so that people can't just riffle your files.
<p>
If your Perl supports the <code>alarm()</code> system call, which any
port worth its salt does,
requests have to be received within a few seconds of startup or the
socket is closed. This is a paranoia feature to help cut down on clients
maliciously holding sockets open.
<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0>
<tr><td bgcolor = "#e0e0ff">
As of 0.99, HTTPi does include a tool to let you make a directory browseable
if you like (but subdirectories of that directory won't be unless you take
the same steps with them). Copy <code>browsed</code> from the
<code>tools/</code> directory in the distribution to the desired directory.
Rename it to <code>index.html</code> and make sure it's executable, e.g.
<pre>
% chmod ugo+x index.html
</pre>
Then access the directory like a regular resource (try <a href =
"old-dists/"><code>http://httpi.floodgap.com/old-dists/</code></a> for an
example).
</td></tr></table><p>
<h4>User Filesystems</h4>
As of 0.99, you can now allow your users to serve documents from the
<code>public_html/</code> subdirectory in their home directories with a
URL &aacute; la <a href =
"/~spectre/"><code>http://www.floodgap.com/~spectre/</code></a>.
This is a configure-time option done at time of installation. (This is
assuming you're using Unix; other OSes may tune out for a bit.) The same
rules apply: if it's readable relative to the web server's uid, it's
displayed; if it's executable, it's executed; if it's neither, the client
gets a 404.
<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#ffe0e0">
<b>Attention!</b>
Executables are an issue, as you might be running untrusted code under the
web server's uid if you're not careful. <i>There is no current way to
selectively allow only some users or no users at all to have executables.</i>
Read the section on <a href = "#exec">executable support</a> carefully before
you enable the user filesystem, as well as the HTTPi Security Model below.
</td></tr></table><p>
<h4>The HTTPi Security Model</h4>
In 1.4, a new method which HTTPi uses to assign its (effective and/or real)
uid and gid for operations became available;
as of 1.7, this became the new default and mandatory.
<p>
In the old system, the server only changed its uid/gid on executables,
if it could do so. No
attempt was made to enforce which uids were legal until the most recent
versions, although as a side
effect, no <code>root</code>-owned
executables were allowed to execute and this was later
assimilated as a "feature".
Documents were served, and server-parsed documents, including inline Perl
blocks, ran, with the webserver's uid/gid.
<p>
In the new (and current)
HTTPi Security Model, the server changes uid/gid for <i>all</i> documents to the
owner of the document, if it can do so.
This includes server-parsed documents, including
those using inline Perl, and all executables, meaning the serving and
execution of all content is restricted to the privileges of the user who
owns the file being served. In fact, this includes even completely static
documents and files. Moreover, a minimum uid can be specified to
indicate which uids may serve documents. This has the following effects:
<p>
<ul>
<li>uid 0 (<code>root</code>) and gid 0
are explicitly disabled.
Documents owned by either uid 0 or gid 0, as well as any executable file owned
by them, are categorically proscribed and cannot be accessed, no
matter what.
<p>
<li>All files owned by a uid lower than the minimum uid are proscribed and
cannot be accessed. (However, specifying a minimum uid of zero won't allow
superuser-owned files to be served, as uid 0 and gid 0 are
never allowed to serve documents; see above.) So, even if a malignant or
clueless user put a symlink to a private or secured system directory (like
<code>/etc</code> or <code>/var/adm</code> or other sensitive locations)
somewhere visible to the webserver, as long as the files within it
are owned by a proscribed uid, they can't be accessed.
<p>
<li>As the process has changed uid, the child process serving the document
or executable is now owned by the owner of the document or executable and
the document owner can now send the child server process signals, including
termination signals if desired. (This may or may not be advantageous.)
The master server continues to run with the original uid.
<p>
<li>Logging is done before the uid switch.
<p>
<li>Depending on your operating system, accessing files owned by
<code>nobody</code> may have strange interactions.
<p>
<li>Files in the virtual filesystem do not have "owners" per se and are
served with the server's original uid.
<p>
<li><code>stat()</code> is used to evaluate the permissions of the file,
meaning that symlinks will not disguise a file's true uid/gid. For example,
a symlink to <code>/etc/passwd</code> would still evaluate as owned by
<code>root</code>, and cannot be served.
<p></ul>
Even if the web server is unable to mutate its uid/gid to the document owner
and must do operations as "itself" (when it's not running as
<code>root</code>), it
will still enforce the minimum uid constraint, and will still enforce the
restrictions on files owned by either uid or gid 0.
<p>
<a name = "htho"><h3>Virtual Hosting with HTTPi</h3></a>
<h4>IP-Based Virtual Hosting</h4>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#ffe0e0">
This option is <b>not</b> available to <code>inetd</code> installations.
</td></tr></table><p>
IP-based virtual hosting (one IP address per virtual host) is handled by
individual, distinct instances of HTTPi binding each IP address. <b>You must
run <code>configure</code> for each build, and specify different absolute
paths for each build so that each <code>configure</code> does not overwrite
others.</b>
<p>
Each IP-based virtual server is an individual, distinct process and is
separate from all others. If you are using Demonic HTTPi, each server must
also be booted separately; the other flavours of HTTPi will require separate
entries in the superserver's configuration. For
managing these individual processes, see <a href = "#ssto">Starting and
Stopping HTTPi</a>.
<h4>IP-Less Virtual Hosting Using <code>%nameredir</code></h4>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#e0e0ff">
This option is available to all flavours of HTTPi.
</td></tr></table><p>
<b>This is only applicable if you have enabled IP-less virtual hosting with
<code>configure</code> in your HTTPi build. Warning: Perl knowledge required
for this section.</b>
<p>
The IP-less virtual hosting feature uses a hash, with your virtual servers as
the keys mapping to locations in the real file system on the actual server
(the actual server is based on whatever you entered as the fully-qualified
domain name of the server during the <code>configure</code> process, so this
last is very important). Here's an example, from this server itself:
<pre>
%nameredir = (
	 "stockholm.floodgap.com" => "http://www.floodgap.com",
	 "httpi.floodgap.com" => "http://www.floodgap.com/httpi",
	);
</pre>
Based on the above, a request for
<code>http://httpi.floodgap.com/serve.html</code>
becomes mapped to <code>http://www.floodgap.com/httpi/serve.html</code>.
In the same way, a request for <code>http://stockholm.floodgap.com/httpi/</code>
becomes mapped to <code>http://www.floodgap.com/httpi/</code>.
Since HTTPi has been told the real name of the server is
<code>www.floodgap.com</code>, HTTPi then relies on this hash to
handle requests for the other virtual servers this machine runs.
<p>
You <i>must</i> specify an entry for <i>every</i> possible name your server
should respond to if IP-less virtual hosting is turned on;
if the request is not for the real name of the server or for any of
the aliases in <code>%nameredir</code>, the client gets a 404.
Note that, using the redirection hash above as written, a request for
<code>http://floodgap.com/</code> will fail with a 404: it must be
<code>http://www.floodgap.com/</code>.
<p>
Also note that, unlike IP-based virtual hosting, this all occurs within one
server process. <b>You do not need individual processes per IP-less virtual
server.</b>
<p>
<b>To edit the <code>%nameredir</code> hash, please see the <a href =
"program.html">programming manual</a> about using the <code>configure</code>
system to help you build new versions of HTTPi, and then edit the
<code>uservar.in</code> (for versions before 1.2, edit <code>httpi.in</code>)
file in the distribution according to the <a href
= "program.html#uvar">manual's instructions.</a></b>
<a name = "exec"><h3>Executables</h3></a>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#ffe0e0">
<b>Attention!</b> Your CGIs will almost certainly <i>not work directly</i> in
HTTPi! Read carefully!
</td></tr></table><p>
As mentioned, HTTPi supports executable programs of a fashion, but not as
CGI, though some interface features are common.
<p>
When a file being requested is executable by HTTPi's uid, it sets a few
environment variables and transforms itself (via <code>exec()</code> or
another method, explained later) into the executable instead.
If HTTPi is running as
<code>root</code>,
it and therefore the executable will assume the egid and euid of the
executable's owner. <i>It does not act like
CGI: you must explicitly set an HTTP response code and you do not
have all the CGI environment variables at your disposal.</i> Think of it as
a very stripped down NPH-CGI environment, where no headers are provided you.
Executables need not have a
<code>.cgi</code> extension, and they don't have to be in any particular
directory save the document one (i.e. there is no explicit
<code>/cgi-bin</code> directory).
<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#e0e0ff">
Regardless of whether the webserver is itself running as
<code>root</code>,
no <code>root</code>-owned or gid 0-owned executable may be executed (in
1.4+),
as well as any constraints you specify in the HTTPi Security Model.
</td></tr></table><p>
The file <code>noodle</code>, included with the distribution in the
<code>tools/</code> directory, allows you to
see what happens. <code>chmod</code> it executable (e.g.
<pre>
% chmod ugo+x noodle
</pre>
), pop it in the documents directory, and access it as a regular resource
(try it <a href = "noodle?this+is+a+variable&q=here+is+another">on this
server</a> and see for yourself). It
will display its uid, gid, euid, egid, arguments and environments. You are
provided the <code>REMOTE_HOST</code>, <code>REMOTE_ADDR</code>,
<code>REMOTE_PORT</code>, <code>QUERY_STRING</code>,
<code>SCRIPT_NAME</code>, <code>SCRIPT_FILENAME</code>,
<code>SERVER_PROTOCOL</code>, <code>SERVER_PORT</code>,
<code>SERVER_SOFTWARE</code>, <code>REQUEST_METHOD</code>,
<code>SERVER_URL</code>, <code>CONTENT_TYPE</code> (for POST requests),
<code>CONTENT_LENGTH</code> (for POST requests),
<code>HTTP_USER_AGENT</code> and <code>HTTP_REFERER</code> environment
variables. In addition, as of 1.4, you are also provided the
<code>HTTP_COOKIE</code> header with any cookies sent by the client, and
as of 1.6, <code>HTTP_ACCEPT_*</code>, <code>HTTP_ACCEPT</code>, 
<code>HTTP_IF_MODIFIED_SINCE</code> and <code>HTTP_X_REQUESTED_WITH</code>;
and if you have 1.7+ and you enable <code>PATH_INFO</code>, you also will
get <code>PATH_INFO</code> where applicable.
<p>
Here's the good news:
most NPH CGIs will probably need no modification at all, and most other CGIs
will simply need you to add an
extra header to explicitly set an HTTP response code, i.e. add
<pre>
HTTP/1.0 200 OK
</pre>
as the first line of whatever output the CGI spews. In Perl, you might use
<pre>
print stdout "HTTP/1.0 200 OK\r\n";
</pre>
to do this, and then call whatever routine prints your content-type.
<p>
Because HTTPi has already ceased to exist by the time the executable starts,
there is no way it can know if the executable succeeded or failed. 
Executables appear in the log file with a status code of 100 instead of 200,
302 or 500, the normal codes seen associated with executables.
<p>
Note that the <code>REMOTE_HOST</code> variable may be affected if you
enable DNS anti-spoofing at configure time in 1.5 and up. If your
executables are expecting a directly-resolvable string to be present,
you should modify the executable or disable anti-spoofing.
<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0>
<tr><td bgcolor = "#e0e0ff">
Certain filesystems may not have reliable execute bits. For those systems,
you can force only certain extensions to be executable (i.e., the file
must not only have execute bits, but must end in
<code>(exe|com|pl|cgi|cmd|perl|[ckbap]*sh)</code>). This is available in 1.6
as a configure-time option.
</td></tr>
</table>
<h4>HTTPerl vs. <code>exec()</code></h4>
As of 0.7, HTTPi gives you two ways of running your executables.
When configuring HTTPi, you can either choose to use the HTTPerl hack, or do a
regular <code>exec()</code>. There are significant advantages and
disadvantages to both.
<p>
The normal method, and the method used in HTTPi 0.4 and earlier, is to
<code>exec()</code> into a new process and completely replace HTTPi and Perl
with whatever the new executable process will be. This works everywhere
and on just about everything,
but is needless overhead if the new executable process happens to be Perl
or a Perl script because now Perl needs to be re-invoked all over again.
<p>
The HTTPerl hack, then, is pretty easy to understand conceptually.
HTTPerl works by re-using the current Perl interpreter that is running HTTPi
to run the executable. This has one obvious advantage and one obvious
disadvantage: you don't need to re-invoke Perl again, but at the same time
every one of your executables that HTTPi runs directly must be in Perl. This
means that if you have any binary executables, you must make a Perl wrapper
for them that will do the <code>exec()</code> at that point. On the other
hand, HTTPerl is in
general much, much faster than blindly <code>exec()</code>ing into
a new process.
<p>
There is one other major quirk in HTTPerl that you need to be aware of:
HTTPerl basically does the equivalent of a <code>require</code> on the
executable. This means that your executable also has access to all the
<a href = "program.html">internal globals and functions</a> that HTTPi
exposes, a double-edged sword as your executable or its modules might already
be using globals and functions with the same names, but at the same time you
don't have to provide any HTTP negotiation code yourself. Moreover, as a
result of the way it is invoked, your
executable runs within the server (it becomes <i>part</i> of the server),
so HTTPi will do error handling for you unless you catch the
<code>__DIE__</code> pseudosignal handler first.<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#ffe0e0">
<b>Warning!</b>
One big gotcha is that
the server will gripe if you don't return a true value in HTTPerl.
Adding a <code>1;</code> at the end will suffice, and keep it compatible
with regular CGI-based webservers.
</td></tr></table>
<p>
In short, <code>exec()</code> is the default because it will handle all
cases with no problems. However, if your Perl executables work with HTTPerl,
you will find it a much faster solution. <i>Just test thoroughly first!</i>
<p>
(Note that speed gains may be reduced if your filesystem cache is fat and
therefore its copy of the Perl executable doesn't have to be flushed
out often. This may be the case on systems with lots of memory; in those cases,
HTTPerl's quirks may not be worth the slight speed edge. Try it and see.)
<a name = "inpl"><h3>Inline Perl and the <code>&lt;perl&gt;</code> Tag</h3></a>
<b>This is only applicable if you have enabled inline Perl when you built
your executable with <code>configure</code>.</b><p>
HTTPi 1.0 and up offer the ability to embed Perl in server-parsed HTML files.
This feature is very useful and also very <i>dangerous</i> (particularly if
you have the user filesystem enabled, as it allows anyone to execute arbitrary
Perl with the webserver's uid). Although the HTTPi Security Model improves
this feature's security, it still has tremendous power for problem as well
as promise.
<p>
As this feature requires some knowledge of the internals of HTTPi, it is
given its own section in the <a href = "program.html#inpl"><b>Programmer's
Manual</b></a>.
<a name = "secu"><h3>HTTPi Security and the Restriction Matrix</h3></a>
<b>This is only applicable if you have enabled the restriction matrix
facility when you built your executable with <code>configure</code>.</b>
<p>
Since HTTPi lends itself to adding a quick webserver wrapper around
applications, a frequent use for HTTPi is as a cheap interface to a network
monitor or some data acquisition tool. Equally frequently, this data is
sensitive.
<p>
HTTPi has an allow/deny authorization scheme called the <i>restriction
matrix</i>, a hash in the program that allows the user to create restrictions
for a particular directory or resource to certain network addresses,
user agents, browsers, or clients, or (as of 0.99) specified user/password
pairs. <b>Warning: Perl knowledge required for this section.</b>
<p>
The restriction matrix is hard-coded into HTTPi.
Here's two sample entries (in fact, the default ones included in HTTPi):
<pre>
%restrictions =
        ("/nw" => "^10\.##^Mozilla#MSIE",
         "/status" => "####voyeur:daNrZR3TcSwD2");
</pre>
<b>To edit the <code>%restrictions</code> hash, please see the <a href =
"program.html">programming manual</a> about using the <code>configure</code>
system to help you build new versions of HTTPi, and then edit the
<code>uservar.in</code> (for versions before 1.2, edit <code>httpi.in</code>)
file in the distribution according to the <a href
= "program.html#uvar">manual's instructions.</a></b>
<p>
The first entry indicates that for all resources starting with
<code>/nw/</code>, only
addresses 10.*.*.* are allowed, and of that set, only browsers that report a
user agent string of Mozilla and do not have MSIE. By now it should
be obvious that this is nothing more than four regular expressions concatenated
together with #s, in this order:
<p>
<ul>
<li>allowed hosts (IP numbers only)
<li>denied hosts (IP numbers only)
<li>allowed user agents/browsers
<li>denied user agents/browsers
</ul>
The second entry has no allow/deny rules, but does have an optional fifth
parameter valid only as of 0.99. This entry restricts all resources starting
with <code>/status</code> (so the Demonic STATIOS module) to any IP address
and any browser, but only those logging in as <code>voyeur</code> with
password <code>wannapeek</code>, which is put in the file in
<code>crypt()</code>
format. Multiple user name:password pairs can be here, separated by commas.
<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#e0e0ff">
The <code>crapword</code> utility in the <code>tools/</code> distribution
directory is a quick way to encrypt a password. Alternatively, you could
copy the username-password pair from <code>/etc/passwd</code> or your
appropriate shadow password file (Unix) or
use the common <code>htpasswd</code> utility. For compatibility reasons,
HTTPi does not use <code>getpwnam()</code> or <code>getpwent()</code> to
access the password file.
</td></tr></table><p>
Allow/deny rules have this precedence:
<p>
<ul>
<li>
If an allow rule is present, but no deny rule, then if the rule
is satisfied by the current parameter (user agent, IP
number), the client is <b>allowed</b>.
<p>
<li>
If a deny rule is present, but no allow rule, then if the rule
is satisfied by the current parameter, the client is <b>disallowed</b>.
<p>
<li>
If both rules are present, the allow rule is tested, and then the deny rule.
If the allow rule is satisfied, and the deny rule is not, the client is
<b>allowed</b>. Otherwise, the client is <b>disallowed</b>.
<p>
</ul>
Once the allow/deny rules have been passed, HTTPi checks the user credentials
required, if specified in the matrix. If the user credentials are correct,
the client is <b>allowed</b>. Otherwise, the client is <b>disallowed</b>.
<p>
In the first line of the example, there is an allow and deny rule for the user
agent. Microsoft Internet Explorer exports a user-agent string of the form
<code>Mozilla/V.v (... MSIE ...)</code>. It will satisfy the allow rule
<code>^Mozilla</code> <i>and</i> the deny rule <code>MSIE</code>, and thus
be <b>disallowed</b>. Mozilla Firefox exports a user-agent string of the
form <code>Mozilla/V.v (...)</code>. It will satisfy the allow rule
<code>^Mozilla</code>, but not satisfy the deny rule, and thus will be
<b>allowed</b>. Lynx (<code>Lynx ...</code>) will fail the allow rule and the
deny rule, and will be <b>disallowed</b>.
<p>
The IP address scheme works similarly.
<p>
There is no user:password pair, so HTTP authentication is not required for the
first example. The second example does require it.
<p>
To add additional restrictions for additional directories, simply add hash
rows with the resource prefix, directory, etc., as the key and the restriction
string as the value to the <code>%restrictions</code> hash -- <b>please
read <a href = "program.html">the programmer's guide</a> for important
information on building new HTTPi versions.</b> Restrictions are prioritized
in descending order by
resource prefix length (i.e. <code>"/foo/bar"</code> takes precedence over
<code>"/foo/"</code> takes precedence over <code>"/"</code>). Naturally, if
no restriction matrix entry exists that matches a particular resource, it
is allowed to all clients and all network addresses.
<p>
When a client is disallowed due to a disallowed IP address or client, it is
sent the standard HTTP error code 403
along with an explanation. With the first rule above in place,
<a href = "/nw/">this resource</a>
can only be accessed from hosts on the internal
network, and then only by Netscape clients.
<p>
When a client is disallowed due to an incorrect user name or password, it is
sent the standard HTTP error code 401 and an explanation. With the second
rule above in place, <a href = "/status">this resource</a>
can only be accessed by users providing username <code>voyeur</code> and
password <code>wannapeek</code>.
<a name = "virt"><h3>Virtual Filesystem Support</h3></a>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#e0e0ff">
This option is supported in Demonic HTTPi only.
</td></tr></table><p>
<b>This is only applicable if you have enabled the virtual file system with
<code>configure</code> in your HTTPi build. Warning: Perl knowledge required
for this section.</b>
<p>
The virtual filesystem allows you to "preload" files, or even embed them
in the server, and then have them served completely from memory. Think of it
as a fast, stupid, non-dynamic disk cache. This is particularly useful for
small images that get frequently referenced, for example, or other kinds of
small files. There are a few caveats:
<p>
<ul><li>Each virtual file entry takes memory, obviously.
<li>The file cannot be changed throughout the life of the master server. If
you alter the file, you must reboot Demonic HTTPi for the change to take
effect.
<li>You cannot preload an entire filesystem (it would probably require
prohibitive memory overhead anyway), but must do files individually.
<li>You need to know your file's MIME type.
<li>If a preloaded file is an executable, or a file with embedded Perl
blocks, the file itself will be sent, without having been executed, directly
to the user with no parsing.
<p>
</ul>
The entries that make up the virtual filesystem are in the
<code>%virtual_files</code> hash in <code>uservar.in</code>. Each hash key
is a fully-qualified file specification, and references an list reference
that has three elements. The first element is the virtual file's MIME type
(yes, it's redundant, but you also have the flexibility to override this for
other purposes). The second is the type of data to follow: <code>FILE</code>
if you wish to reference an actual file and preload that, or <code>DATA</code>
if you're actually inlining data. The third is the data itself: either an
absolute, fully-specified path to the file to be preloaded, or data to be
inlined.
<p>
The default <code>%virtual_files</code> hash in the HTTPi distribution
looks like this:
<pre>
%virtual_files =
        ("/httpi/pix/httpismall.gif" => [ "image/gif", "FILE",
                "/usr/local/htdocs/httpi/pix/httpismall.gif" ] ,
         "/httpi/virtualfile.html" => [ "text/html", "DATA",
                "&lt;html&gt;&lt;body&gt;Look, Ma, I'm virtual!&lt;/body&gt;&lt;/html&gt;" ] ,
        );
</pre>
The first hash entry tells Demonic HTTPi to load
<code>/usr/local/htdocs/httpi/pix/httpismall.gif</code> into memory and
when a request comes along, instead of looking for it on disk, to serve
it directly from its memory store with a MIME type of <code>image/gif</code>.
Try <a href = "/httpi/pix/httpismall.gif">downloading the image</a>.
<p>
The second hash entry tells Demonic HTTPi to match the inlined text data
with any requests for <code>/httpi/virtualfile.html</code>. When a request
for that file comes along, instead of looking for it on disk, the server
instead retrieves it from its memory store and serves it with a MIME type
of <code>text/html</code>. Most important of all, this file actually
does not exist anywhere on this server's hard disk -- it is entirely a
figment of HTTPi's imagination, so to speak. Try <a href =
"/httpi/virtualfile.html">viewing it</a>.
<p>
The <code>Last-Modified</code> HTTP header works slightly bizarrely when a
virtual file is served. Instead of being that of the original file referenced,
since there may not even <i>be</i> an original file to reference, the
modification date of virtual files is considered to be the time when the
server was invoked, which, if you think about it, is technically true, too.
(The <code>$statiosuptime</code> variable is used for this purpose, so
even if you don't have STATIOS enabled, this is still defined.)
This makes the code simpler rather than having to carry around file attributes
as excess memory baggage, and allows the interface to be abstracted to
include files that really <i>are</i> virtual and wouldn't have a
modification date per se, as well.
<p>
If an entry in the hash is the same as a file that really does exist, the
virtual filesystem entry always takes precedence.
<p>
The HTTPi Security Model has no effect on how virtual filesystem entries are
served.
<p>
<b>To edit the <code>%virtual_files</code> hash, please see the <a href =
"program.html">programming manual</a> about using the <code>configure</code>
system to help you build new versions of HTTPi, and then edit the
<code>uservar.in</code>
file in the distribution according to the <a href
= "program.html#uvar">manual's instructions.</a></b>
<a name = "thrs"><h3>Throttling Support</h3></a>
As of 1.4, an exceptionally primitive and dumb, but effective, bandwidth
throttling option is available, allowing you to limit how fast requests
are served to users.
<p>
In an attempt to use as portable and uncomplicated a method as
possible, the
bandwidth throttling method is implemented overly simplistically.
At configure time, you
specify how big a "gulp" to take and spew over the network, and then how
long should elapse between said gulps. For example, specifying 16K (this
should be given to the configure script in bytes, so, 16384 bytes) and
one second intervals means an effective average limit of 16K/sec on
outgoing transfers.
Most people will want to use a one-second interval to obtain as direct a
bytes/second
limit as possible, but you may have valid uses for increasing this interval
(see below).
<p>
<table width = 100% cellspacing = 2 cellpadding = 5 border = 0><tr>
<td bgcolor = "#ffe0e0">
The interval pause is implemented in terms of the <code>sleep</code>
function, which may inherit the limitations of your local
implementation and operating system, including failing to sleep for
the exact time specified.
</td></tr></table><p>
Virtual files, executables and server-parsed documents (including inline
Perl blocks) are <i>not</i> subject to throttling.
<p>
Throttling occurs on a per-process basis, not per server or
installation. If you have a very
busy site and absolutely must maintain as low a bandwidth impact as possible,
one possible way to lower the impact is to turn up the interval. This will
spread out data pulses to clients and allow more server instances a greater
chance to transmit their data. However, there is currently no way in this
version of HTTPi
to enforce an aggregate transmission limit over all processes that the
master HTTPi instance has spawned.
<h3>Questions and Bug Reports</h3>
Send all outstanding issues to <b><a href =
"mailto:httpi@floodgap.com">httpi@floodgap.com</a></b>.
<hr>
<address>Cameron Kaiser</address>
</body>
</html>
